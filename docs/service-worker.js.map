{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./app/src/sw.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","urlsToCache","self","workbox","precaching","precacheAndRoute","__WB_MANIFEST","globPatterns","modifyURLPrefix","clientsCliem","skipWaiting","ignoreURLParametersMatching","offlineGoogleAnalytics","maximumFileSizeToCacheInBytes","runtimeCaching","urlPattern","handler","options","cacheName","expiration","maxAgeSeconds","maxEntries","addEventListener","event","console","log","waitUntil","caches","open","then","cache","addAll","respondWith","match","request","response","fetchRequest","clone","fetch","status","type","responseToCache","put","cacheAllowlist","keys","cacheNames","Promise","all","map","indexOf","delete"],"mappings":"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","file":"service-worker.js","sourceRoot":"","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Service Worker\n * \n * Memberikan dukungan offline saat koneksi tidak ada atau terputus.\n * \n * @author wadahkode <mvp.dedefilaras@gmail.com>\n * @since version 1.0.0\n */\nconst CACHE_NAME = 'wadahkode-cache-v1';\nconst urlsToCache = [\n  '/portofolio/',\n  '/portofolio/article',\n  '/portofolio/product',\n  '/portofolio/index.html',\n  '/portofolio/login.html',\n  '/portofolio/register.html',\n  '/portofolio/about.html',\n  '/portofolio/tools',\n  '/portofolio/assets/avatar/me.jpg',\n  '/portofolio/assets/avatar/no-image.png',\n  //'/assets/images/*/*',\n  '/portofolio/vendor/fontawesome/js/all.min.js',\n  //'/vendor/fontawesome/*/*',\n  '/portofolio/vendor/jquery/dist/jquery.min.js',\n  '/portofolio/vendor/uikit/js/uikit.min.js',\n  '/portofolio/vendor/uikit/js/app.min.js',\n  '/portofolio/favicon.jpg'\n];\n\nif ('workbox' in self) {\n    workbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);\n    workbox.globPatterns([\n        \"**/*.{css,js,eot,ttf,woff,woff2,otf,jpg,webp}\"\n    ]);\n    workbox.modifyURLPrefix({\n        \"\": \"/portofolio/\"\n    });\n    workbox.clientsCliem(true);\n    workbox.skipWaiting(true);\n    workbox.ignoreURLParametersMatching([/./]);\n    workbox.offlineGoogleAnalytics(true);\n    workbox.maximumFileSizeToCacheInBytes(5 * 1024 * 1024);\n    workbox.runtimeCaching([\n        {\n            urlPattern: /(?:\\/)$/,\n            handler: \"NetworkFirst\",\n            options: {\n            cacheName: \"html\",\n            expiration: {\n                   maxAgeSeconds: 60 * 60 * 24 * 7,\n                },\n            },\n        },\n        {\n            urlPattern: /\\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/,\n                handler: \"CacheFirst\",\n                options: {\n                    cacheName: \"images\",\n                    expiration: {\n                        maxEntries: 1000,\n                        maxAgeSeconds: 60 * 60 * 24 * 365,\n                    },\n                },\n        },\n        {\n            urlPattern: /\\.(?:mp3|wav|m4a)$/,\n                handler: \"CacheFirst\",\n                options: {\n                    cacheName: \"audio\",\n                    expiration: {\n                        maxEntries: 1000,\n                        maxAgeSeconds: 60 * 60 * 24 * 365,\n                    },\n                },\n        },\n        {\n            urlPattern: /\\.(?:m4v|mpg|avi)$/,\n                handler: \"CacheFirst\",\n                options: {\n                    cacheName: \"videos\",\n                    expiration: {\n                        maxEntries: 1000,\n                        maxAgeSeconds: 60 * 60 * 24 * 365,\n                    },\n                },\n        }\n    ]);\n}\n\nself.addEventListener('install', function(event) {\n    console.log(event);\n    // Perform install steps\n    event.waitUntil(\n        caches.open(CACHE_NAME)\n        .then(function(cache) {\n            console.log('Opened cache');\n            return cache.addAll(urlsToCache);\n        })\n    );\n});\n    \nself.addEventListener('fetch', function(event) {\n  event.respondWith(\n    caches.match(event.request)\n      .then(function(response) {\n        // Cache hit - return response\n        if (response) {\n          return response;\n        }\n\n        // IMPORTANT: Clone the request. A request is a stream and\n        // can only be consumed once. Since we are consuming this\n        // once by cache and once by the browser for fetch, we need\n        // to clone the response.\n        var fetchRequest = event.request.clone();\n\n        return fetch(fetchRequest).then(\n          function(response) {\n            // Check if we received a valid response\n            if(!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n\n            // IMPORTANT: Clone the response. A response is a stream\n            // and because we want the browser to consume the response\n            // as well as the cache consuming the response, we need\n            // to clone it so we have two streams.\n            var responseToCache = response.clone();\n\n            caches.open(CACHE_NAME)\n              .then(function(cache) {\n                cache.put(event.request, responseToCache);\n              });\n\n            return response;\n          }\n        );\n      })\n    );\n});\n\nself.addEventListener('activate', function(event) {\n  const cacheAllowlist = ['wadahkode-cache-v1', 'blog-posts-cache-v1'];\n\n  event.waitUntil(\n    caches.keys().then(function(cacheNames) {\n      return Promise.all(\n        cacheNames.map(function(cacheName) {\n          if (cacheAllowlist.indexOf(cacheName) === -1) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});"]}